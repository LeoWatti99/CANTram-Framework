\doxysection{ESP32\+\_\+\+UART Class Reference}
\hypertarget{class_e_s_p32___u_a_r_t}{}\label{class_e_s_p32___u_a_r_t}\index{ESP32\_UART@{ESP32\_UART}}


Inheritance diagram for ESP32\+\_\+\+UART\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=180pt]{dc/d41/class_e_s_p32___u_a_r_t__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for ESP32\+\_\+\+UART\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=180pt]{d8/dd5/class_e_s_p32___u_a_r_t__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_e_s_p32___u_a_r_t_abcf659dfcf87f375296a9ecba9e0cd1b}\label{class_e_s_p32___u_a_r_t_abcf659dfcf87f375296a9ecba9e0cd1b} 
enum {\bfseries uart\+State} \{ {\bfseries NONE}
, {\bfseries INSTALLED}
, {\bfseries CONFIGURED}
, {\bfseries STARTED}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{class_u_a_r_t_core}{UARTCore}}}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_u_a_r_t_core_a1895842f7c33678bdf154e12cc617903}{Data\+Bits}} \{ {\bfseries UART\+\_\+\+DATA\+\_\+5\+\_\+\+BITS} = 0
, {\bfseries UART\+\_\+\+DATA\+\_\+6\+\_\+\+BITS} = 1
, {\bfseries UART\+\_\+\+DATA\+\_\+7\+\_\+\+BITS} = 2
, {\bfseries UART\+\_\+\+DATA\+\_\+8\+\_\+\+BITS} = 3
 \}
\begin{DoxyCompactList}\small\item\em Possible data bit widths for UART communication. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity}} \{ {\bfseries UART\+\_\+\+PARITY\+\_\+\+NONE} = 0
, {\bfseries UART\+\_\+\+PARITY\+\_\+\+EVEN} = 1
, {\bfseries UART\+\_\+\+PARITY\+\_\+\+ODD} = 2
 \}
\begin{DoxyCompactList}\small\item\em \doxylink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity} configuration options. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{class_u_a_r_t_core_ab88ed673e8897a7804c27ac7d749f00b}{Stop\+Bits}} \{ {\bfseries UART\+\_\+\+STOP\+\_\+\+BITS\+\_\+1} = 1
, {\bfseries UART\+\_\+\+STOP\+\_\+\+BITS\+\_\+1\+\_\+5} = 2
, {\bfseries UART\+\_\+\+STOP\+\_\+\+BITS\+\_\+2} = 3
 \}
\begin{DoxyCompactList}\small\item\em Stop bit configuration options. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Types inherited from \mbox{\hyperlink{class_hardware_resource}{Hardware\+Resource}}}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6}{Type}} \{ \newline
\mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6ac6f39e4a2dbc764df53048f26209f0a1}{UART}}
, \mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6a63a2eead0d2771007afa8c8af281c50d}{SPI}}
, \mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6ac77292ec986f613995babba396598dbc}{I2C}}
, \mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6ac2fe3e8cc9a9a8fcb39c32be2da214c5}{PWM}}
, \newline
\mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6a0ae946256af51077cacc3c0a11575635}{CAN}}
 \}
\begin{DoxyCompactList}\small\item\em Enumeration of hardware resource types. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a0729d44483caad65176f225c7924755c}{reset}} () override
\begin{DoxyCompactList}\small\item\em Reset the ESP32 UART instance. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a6da4b5cb2f0ffee5af03f66224e4bcb2}{install}} (int uart\+\_\+num, uint8\+\_\+t tx\+\_\+pin, uint8\+\_\+t rx\+\_\+pin, uint16\+\_\+t buffer\+Size) override
\begin{DoxyCompactList}\small\item\em Install the UART driver and prepare the instance. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a1a0b6a3517aeeda8f92cb43054d47436}{apply\+Config}} ()
\begin{DoxyCompactList}\small\item\em Configure UART communication parameters. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a6f02dc1304c5cd10b1e24a29e1c06b0c}{apply\+Pins}} (int tx\+\_\+pin, int rx\+\_\+pin)
\begin{DoxyCompactList}\small\item\em Set TX and RX pins and start the UART peripheral. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_acdf2bf644ded75b797ef85f44fcb5f60}{apply\+Pins}} ()
\begin{DoxyCompactList}\small\item\em Apply previously stored TX/\+RX pin mapping. \end{DoxyCompactList}\item 
\Hypertarget{class_e_s_p32___u_a_r_t_a698cca5da1214e996e917328939decc4}\label{class_e_s_p32___u_a_r_t_a698cca5da1214e996e917328939decc4} 
void {\bfseries set\+UARTPort} (uart\+\_\+port\+\_\+t uart\+Port)
\item 
bool \mbox{\hyperlink{class_e_s_p32___u_a_r_t_aa16ed83457d3ddb3ca9290581082fcba}{send}} (const char buffer\mbox{[}$\,$\mbox{]}, size\+\_\+t size) override
\begin{DoxyCompactList}\small\item\em Send a buffer of bytes over UART. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a9347eb37496924596031fac5adbfca56}{read}} (char buffer\mbox{[}$\,$\mbox{]}) override
\begin{DoxyCompactList}\small\item\em Read available bytes from UART into buffer. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_e_s_p32___u_a_r_t_ab7b05058426c5c21323ba8b113f2ec5e}{available}} () override
\begin{DoxyCompactList}\small\item\em Get number of bytes available to read. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_e_s_p32___u_a_r_t_a48a03e2bed3b8320ca1f4c65fa814867}{flush}} () override
\begin{DoxyCompactList}\small\item\em Flush UART RX and TX buffers. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{class_u_a_r_t_core}{UARTCore}}}
\begin{DoxyCompactItemize}
\item 
virtual bool \mbox{\hyperlink{class_u_a_r_t_core_a4313ac566018e2da28caa76bd8f35bcb}{config}} (uint32\+\_\+t baudrate, \mbox{\hyperlink{class_u_a_r_t_core_a1895842f7c33678bdf154e12cc617903}{Data\+Bits}} data\+Bits, \mbox{\hyperlink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity}} parity, \mbox{\hyperlink{class_u_a_r_t_core_ab88ed673e8897a7804c27ac7d749f00b}{Stop\+Bits}} stop\+Bits)
\begin{DoxyCompactList}\small\item\em Configure UART communication parameters. \end{DoxyCompactList}\item 
virtual bool {\bfseries set\+Baudrate} (uint32\+\_\+t baudrate)
\item 
virtual bool {\bfseries set\+Data\+Bits} (\mbox{\hyperlink{class_u_a_r_t_core_a1895842f7c33678bdf154e12cc617903}{Data\+Bits}} data\+Bits)
\item 
virtual bool {\bfseries set\+Parity} (\mbox{\hyperlink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity}} parity)
\item 
virtual bool {\bfseries set\+Stop\+Bits} (\mbox{\hyperlink{class_u_a_r_t_core_ab88ed673e8897a7804c27ac7d749f00b}{Stop\+Bits}} stop\+Bits)
\item 
\mbox{\hyperlink{class_hardware_resource_adead6978be3d7b86c18e3d3e051381e6}{Hardware\+Resource\+::\+Type}} \mbox{\hyperlink{class_u_a_r_t_core_af2aad4efeda3999a508c721e8f2ce46e}{get\+Type}} () override
\begin{DoxyCompactList}\small\item\em Get the \doxylink{class_hardware_resource}{Hardware\+Resource} type for this core. \end{DoxyCompactList}\item 
virtual bool {\bfseries set\+Pins} (uint8\+\_\+t tx\+\_\+pin, uint8\+\_\+t rx\+\_\+pin)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{class_hardware_resource}{Hardware\+Resource}}}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_hardware_resource_a26f48b38e5bb1d9bdd47ea2e6de87fdb}{request\+Usage}} ()
\begin{DoxyCompactList}\small\item\em Request a usage slot for this resource. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{class_hardware_resource_a07205354c25627a3bb10ad417e335ff9}{get\+Usages}} ()
\begin{DoxyCompactList}\small\item\em Get the current number of usages of this resource. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_hardware_resource_a569821aa9a34d96ed143488a72e6872b}{is\+Used}} ()
\begin{DoxyCompactList}\small\item\em Check if the resource is currently used. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \mbox{\hyperlink{class_hardware_resource_a470679cae7880c9ca436755a50f68db4}{get\+Remaining\+Usages}} ()
\begin{DoxyCompactList}\small\item\em Get remaining usage capacity for this resource. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{class_hardware_resource}{Hardware\+Resource}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_hardware_resource_a7ddffb890a743f2df28128d9afd5bfa5}{Hardware\+Resource}} ()=default
\begin{DoxyCompactList}\small\item\em Default constructor. \end{DoxyCompactList}\item 
virtual uint8\+\_\+t \mbox{\hyperlink{class_hardware_resource_a6b7a709561faf5d344b7c3e14bf37558}{get\+Max\+Usages}} ()
\begin{DoxyCompactList}\small\item\em Get the maximum simultaneous usages allowed for this resource. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{class_u_a_r_t_core}{UARTCore}}}
\begin{DoxyCompactItemize}
\item 
int8\+\_\+t {\bfseries \+\_\+rx\+Pin} = DEFAULT\+\_\+\+REF
\item 
int8\+\_\+t {\bfseries \+\_\+tx\+Pin} = DEFAULT\+\_\+\+REF
\item 
bool {\bfseries pins\+Configured} = false
\item 
uint32\+\_\+t {\bfseries \+\_\+baudrate} = 0
\item 
\mbox{\hyperlink{class_u_a_r_t_core_ab88ed673e8897a7804c27ac7d749f00b}{Stop\+Bits}} {\bfseries \+\_\+stop\+Bits} = UART\+\_\+\+STOP\+\_\+\+BITS\+\_\+1
\item 
\mbox{\hyperlink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity}} {\bfseries \+\_\+parity} = UART\+\_\+\+PARITY\+\_\+\+NONE
\item 
\mbox{\hyperlink{class_u_a_r_t_core_a1895842f7c33678bdf154e12cc617903}{Data\+Bits}} {\bfseries \+\_\+data\+Bits} = UART\+\_\+\+DATA\+\_\+8\+\_\+\+BITS
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{class_hardware_resource}{Hardware\+Resource}}}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \mbox{\hyperlink{class_hardware_resource_a78845b363f906c0383e91ea912bbddbc}{usages}} =0
\begin{DoxyCompactList}\small\item\em Current usage counter. \end{DoxyCompactList}\end{DoxyCompactItemize}


\label{doc-func-members}
\Hypertarget{class_e_s_p32___u_a_r_t_doc-func-members}
\doxysubsection{Member Function Documentation}
\Hypertarget{class_e_s_p32___u_a_r_t_a1a0b6a3517aeeda8f92cb43054d47436}\index{ESP32\_UART@{ESP32\_UART}!applyConfig@{applyConfig}}
\index{applyConfig@{applyConfig}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{applyConfig()}{applyConfig()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a1a0b6a3517aeeda8f92cb43054d47436} 
bool ESP32\+\_\+\+UART\+::apply\+Config (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Configure UART communication parameters. 

Applies baudrate, data bits, parity and stop bits to the UART peripheral. Requires the instance to be in INSTALLED state prior to calling. 
\begin{DoxyParams}{Parameters}
{\em baudrate} & Desired baud rate (e.\+g., 115200). \\
\hline
{\em data\+Bits} & Data bits selection from \doxylink{class_u_a_r_t_core_a1895842f7c33678bdf154e12cc617903}{UARTCore\+::\+Data\+Bits}. \\
\hline
{\em parity} & \doxylink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{Parity} selection from \doxylink{class_u_a_r_t_core_a53addcd39a841913c86bd7e25cca94a0}{UARTCore\+::\+Parity}. \\
\hline
{\em stop\+Bits} & Stop bits selection from \doxylink{class_u_a_r_t_core_ab88ed673e8897a7804c27ac7d749f00b}{UARTCore\+::\+Stop\+Bits}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if configuration succeeded, false otherwise. 
\end{DoxyReturn}
\Hypertarget{class_e_s_p32___u_a_r_t_acdf2bf644ded75b797ef85f44fcb5f60}\index{ESP32\_UART@{ESP32\_UART}!applyPins@{applyPins}}
\index{applyPins@{applyPins}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{applyPins()}{applyPins()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_acdf2bf644ded75b797ef85f44fcb5f60} 
bool ESP32\+\_\+\+UART\+::apply\+Pins (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Apply previously stored TX/\+RX pin mapping. 

Overload that calls set\+Pins using stored \+\_\+tx\+Pin/\+\_\+rx\+Pin values. \begin{DoxyReturn}{Returns}
true if pins were applied successfully, false otherwise. 
\end{DoxyReturn}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=207pt]{dc/deb/class_e_s_p32___u_a_r_t_acdf2bf644ded75b797ef85f44fcb5f60_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=207pt]{dc/deb/class_e_s_p32___u_a_r_t_acdf2bf644ded75b797ef85f44fcb5f60_icgraph}
\end{center}
\end{figure}
\Hypertarget{class_e_s_p32___u_a_r_t_a6f02dc1304c5cd10b1e24a29e1c06b0c}\index{ESP32\_UART@{ESP32\_UART}!applyPins@{applyPins}}
\index{applyPins@{applyPins}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{applyPins()}{applyPins()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a6f02dc1304c5cd10b1e24a29e1c06b0c} 
bool ESP32\+\_\+\+UART\+::apply\+Pins (\begin{DoxyParamCaption}\item[{int}]{tx\+\_\+pin}{, }\item[{int}]{rx\+\_\+pin}{}\end{DoxyParamCaption})}



Set TX and RX pins and start the UART peripheral. 

Configures the UART peripheral to use the provided pins and transitions the state to STARTED. Requires the instance to be in CONFIGURED state. 
\begin{DoxyParams}{Parameters}
{\em tx\+\_\+pin} & GPIO pin number to use for TX. \\
\hline
{\em rx\+\_\+pin} & GPIO pin number to use for RX. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if pins were set and UART started successfully, false otherwise. 
\end{DoxyReturn}
\Hypertarget{class_e_s_p32___u_a_r_t_ab7b05058426c5c21323ba8b113f2ec5e}\index{ESP32\_UART@{ESP32\_UART}!available@{available}}
\index{available@{available}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{available()}{available()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_ab7b05058426c5c21323ba8b113f2ec5e} 
size\+\_\+t ESP32\+\_\+\+UART\+::available (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Get number of bytes available to read. 

Queries the UART driver\textquotesingle{}s buffered data length and returns the number of bytes ready for reading. \begin{DoxyReturn}{Returns}
size\+\_\+t Number of bytes available. 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_u_a_r_t_core_ace871307d31091740402a97b42eb86ef}{UARTCore}}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{dc/deb/class_e_s_p32___u_a_r_t_ab7b05058426c5c21323ba8b113f2ec5e_icgraph}
\end{center}
\end{figure}
\Hypertarget{class_e_s_p32___u_a_r_t_a48a03e2bed3b8320ca1f4c65fa814867}\index{ESP32\_UART@{ESP32\_UART}!flush@{flush}}
\index{flush@{flush}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a48a03e2bed3b8320ca1f4c65fa814867} 
void ESP32\+\_\+\+UART\+::flush (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Flush UART RX and TX buffers. 

Ensures any queued transmit data is flushed and input buffers are cleared. \begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_u_a_r_t_core_a6c0643b7fc686ab2ef773a86b4e1cc8e}{UARTCore}}.

\Hypertarget{class_e_s_p32___u_a_r_t_a6da4b5cb2f0ffee5af03f66224e4bcb2}\index{ESP32\_UART@{ESP32\_UART}!install@{install}}
\index{install@{install}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{install()}{install()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a6da4b5cb2f0ffee5af03f66224e4bcb2} 
bool ESP32\+\_\+\+UART\+::install (\begin{DoxyParamCaption}\item[{int}]{uart\+\_\+num}{, }\item[{uint8\+\_\+t}]{tx\+\_\+pin}{, }\item[{uint8\+\_\+t}]{rx\+\_\+pin}{, }\item[{uint16\+\_\+t}]{buffer\+Size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Install the UART driver and prepare the instance. 

Installs the UART driver for the given uart\+\_\+num if not already installed, stores pin and port configuration and marks the instance state as INSTALLED. 
\begin{DoxyParams}{Parameters}
{\em uart\+\_\+num} & UART peripheral number to install. \\
\hline
{\em tx\+\_\+pin} & GPIO pin used for TX. \\
\hline
{\em rx\+\_\+pin} & GPIO pin used for RX. \\
\hline
{\em buffer\+Size} & Size in bytes for RX/\+TX buffers. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if installation succeeded, false otherwise. 
\end{DoxyReturn}


Implements \mbox{\hyperlink{class_u_a_r_t_core_aa4f8aee7f125854186d5a451324f5fb8}{UARTCore}}.

\Hypertarget{class_e_s_p32___u_a_r_t_a9347eb37496924596031fac5adbfca56}\index{ESP32\_UART@{ESP32\_UART}!read@{read}}
\index{read@{read}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{read()}{read()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a9347eb37496924596031fac5adbfca56} 
size\+\_\+t ESP32\+\_\+\+UART\+::read (\begin{DoxyParamCaption}\item[{char}]{buffer}{\mbox{[}$\,$\mbox{]}}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Read available bytes from UART into buffer. 

Attempts to read up to the number of bytes currently available. Requires UART to be STARTED. 
\begin{DoxyParams}{Parameters}
{\em buffer} & Destination buffer to receive bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size\+\_\+t Number of bytes read into the buffer (0 if none). 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{class_u_a_r_t_core_a09060493e91d608fb209d8c09675fabe}{UARTCore}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{dc/deb/class_e_s_p32___u_a_r_t_a9347eb37496924596031fac5adbfca56_cgraph}
\end{center}
\end{figure}
\Hypertarget{class_e_s_p32___u_a_r_t_a0729d44483caad65176f225c7924755c}\index{ESP32\_UART@{ESP32\_UART}!reset@{reset}}
\index{reset@{reset}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_a0729d44483caad65176f225c7924755c} 
bool ESP32\+\_\+\+UART\+::reset (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Reset the ESP32 UART instance. 

Releases driver resources, flushes buffers and returns the internal state to NONE. Safe to call if driver is not installed; performs no action in that case. \begin{DoxyReturn}{Returns}
true on successful reset. 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{class_u_a_r_t_core_aeaf04f4297b48fdaee839a2ff9fb4ad4}{UARTCore}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{dc/deb/class_e_s_p32___u_a_r_t_a0729d44483caad65176f225c7924755c_cgraph}
\end{center}
\end{figure}
\Hypertarget{class_e_s_p32___u_a_r_t_aa16ed83457d3ddb3ca9290581082fcba}\index{ESP32\_UART@{ESP32\_UART}!send@{send}}
\index{send@{send}!ESP32\_UART@{ESP32\_UART}}
\doxysubsubsection{\texorpdfstring{send()}{send()}}
{\footnotesize\ttfamily \label{class_e_s_p32___u_a_r_t_aa16ed83457d3ddb3ca9290581082fcba} 
bool ESP32\+\_\+\+UART\+::send (\begin{DoxyParamCaption}\item[{const char}]{buffer}{\mbox{[}$\,$\mbox{]}, }\item[{size\+\_\+t}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}



Send a buffer of bytes over UART. 

Writes the provided buffer to the UART transmit queue. Requires the UART to be STARTED. 
\begin{DoxyParams}{Parameters}
{\em buffer} & Character buffer containing bytes to send. \\
\hline
{\em size} & Number of bytes to send from the buffer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if data was queued/sent successfully, false otherwise. 
\end{DoxyReturn}


Reimplemented from \mbox{\hyperlink{class_u_a_r_t_core_a7119ad4a93b3f7895a1be10623cf35a3}{UARTCore}}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{dc/deb/class_e_s_p32___u_a_r_t_aa16ed83457d3ddb3ca9290581082fcba_cgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/leowa/\+Documents/\+Platform\+IO/\+Projects/\+CANTram\+Framework\+Usage/lib/\+CANTram\+Framework/include/ESP32\+\_\+\+UART.\+h\item 
C\+:/\+Users/leowa/\+Documents/\+Platform\+IO/\+Projects/\+CANTram\+Framework\+Usage/lib/\+CANTram\+Framework/src/hardware/ESP32\+\_\+\+UART.\+cpp\end{DoxyCompactItemize}
